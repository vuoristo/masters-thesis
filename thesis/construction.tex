\chapter{Construction}
\label{chapter:construction}
This chapter describes the implementation of the applications studied in the
experiments. The experiments and their results are described in
\ref{chapter:experiments}. First the common idea behind the video filtering
applications is explained and the filters used are described. After that the
PREESM and OpenEM filter applications are introduced and last the PSE model of
the OpenEM filter application is explained. This chapter is focused on the
design and implementation of the applications.

\section{Filter Application}
\label{sec:filterapp}
Edge detection is an important tool in image processing and computer vision.
Many image processing and computer vision algorithms operate on detected edges.
There is a growing interest in the industry to use DSP platforms for edge
detection based algorithms. In this thesis two filters used in Canny edge
detector are implemented as a part of a image processing application for Texas
Instruments TMS320C6678 DSP. In this section an overview of the Canny edge
detector is given. After that Sobel and Gaussian filter which are both used in
Canny edge detectors and are implemented in this thesis are introduced.\\

TODO: improve intro and find sources for claims. wikipedia on edge detection has
about the same stuff as above.\\
TODO: Explain the why the streams are separate and the frames are not processed
by both of the filters.
\subsection{Canny edge detector}
In his 1986 paper John F. Canny \cite{canny1985computational} lays out the
mathematical criteria for successful edge detection and presents an algorithm,
which is suitable for implementation on DSP platforms and achieves decent edge
detection performance. The Canny Edge Detection consists of five steps
represented in the following list.

\begin{enumerate}
\item{Gaussian filtering}
\item{Sobel filtering}
\item{Non-maximum supression}
\item{Double tresholding}
\item{Edge tracking by hysteresis}
\end{enumerate}

The steps 1. and 2. are implemented in the thesis experiment. Gaussian filtering
is discussed in \ref{subsec:gauss} and sobel filtering in \ref{subsec:sobel}.
The rest of the steps are not implemented in this thesis and thus are only
briefly discussed here.

\subsection{Gaussian filter}
\label{subsec:gauss}
\subsection{Sobel filter}
\label{subsec:gauss}
\section{PREESM Filter Application}
\label{sec:preesmapp}
An actor network is constructed in PREESM that represents the video filter
application. The final PiSDF model of the PREESM video filter application is
presented in figure \ref{preesm_actors}. The PREESM filter application is
adapted from the PREESM tutorial at \cite{preesmtut} by adding another
processing path for gaussian filter and making the necessary modifications to
the shared parts of the application.

\begin{figure}[h!] \label{preesm_actors} \begin{center}
    \includegraphics[width=0.99\textwidth]{images/preesm_diagram.png}
    \caption{The PiSDF graph of the PREESM filter application} \end{center}
\end{figure}

To keep the model simple and the program well analyzable both of the processing
paths in the network are independent.

The first actor on both of the processing paths loads the video frames from
memory and passes them to splitting actors. The splitting actor splits the
frames to a suitable number of splices to enable processing of the same video
stream on multiple cores. The filter actor follows the splitting actor. Partial
frames filtered in the filter actor are merged back to whole frames in the merge
actors. The last actors on both of the processing paths are dummy actors.\\

TODO: explain scheduling

\section{OpenEM Filter Application}
The OpenEM implementation of the filter application was heavily influenced by
the PREESM filter application described in \ref{sec:preesmapp}. Specifically the
OpenEM application has to process the frames in similar manner so that only the
scheduling policies between the two programming models should differ. The PREESM
application splits the frames into slices and processes the slices separately
before merging them back into one frame. Similar fork-join mechanism was
implemented in the OpenEM application. Event groups were first planned to be
used as the fork-join mechanism in the filter application but in the final
implementation a different, simpler mechanism was used.

The TI implementation of event groups lacks \texttt{em\_event\_group\_delete}
function which makes it necessary to reuse the existing event groups. The
example applications which are included in the NSN OpenEM distribution
described in \ref{sec:emframework} demonstrate reuse of event groups, but it
was estimated that the programming overhead resulting from the reuse of the
groups would be larger than implementing the fork-join in a simpler manner.

In the final implementation the frames are accumulated simply in a merge buffer
located in shared memory which is referenced through queue context pointers. The
book keeping for frame completion is handled in the same location. The cache
coherency for the book keeping was handled by marking the memory area the merge
buffer resides in as non-cacheable.

\section{PSE Model of OpenEM Filter Application}
\section{Instrumentation}
