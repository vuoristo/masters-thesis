The objective of this thesis is to study the suitability of OpenEM framework for building stream processing applications. Video streams make up an increasing proportion of the data being transferred in the internet. The processing of video streams requires a lot of computing power, as the streams have increasingly high bitrates and they have to be compressed for transfer and storage. Thus video streams are especially interesting streams to study and were selected as the stream format for the experiments conducted in this thesis.

Three requirements for the workload applications were specified to guide the design. The requirements are presented in the following list.

\begin{enumerate}
    \item{Variable input bitrates}
    \item{Comparability the PREESM and OpenEM applications}
    \item{Highly analyzable}
\end{enumerate}

\textbf{Variable input bitrates} were required of the workload applications to make it possible to study the performance of the OpenEM framework in processing dynamic workloads. Varying the bitrates of the video stream inputs is simple as the frame size of the stream is easy to change and it doesn't affect the algorithms used in any unforeseeable way. \textbf{Comparability of the PREESM and OpenEM applications} was required so the PREESM workload could be used as a baseline implementation. Last requirement for the applications was that they needed to be \textbf{highly analyzable} in order to enable the study of OpenEM performance. An application satisfying these requirements was designed using the PREESM sobel example at \cite{preesmtut} as the starting point and adding another processing component to it. It is important to notice that the actual performance of the filter application in its nominal video filtering task was mostly disregarded. For example the data is copied to a new buffer in every processing stage and the filter algorithms are not optimized for the specific platform. Therefore comparing the performance of the implemented applications to real world implementations of similar applications is not useful.

The idea for using sobel and gauss filters in the same application came from the canny edge detector, which is briefly discussed in \ref{sec:canny}. The canny edge detector only provided ideas of what a realistic video processing application does. The filters in the workload applications are executing independently of each other on separate video streams unlike how they are connected in the canny edge detector. After the introduction to edge detection and the canny edge detector the filter components implemented in this thesis are introduced in \ref{subsec:gauss} introducing the gaussian filter and \ref{subsec:sobel} providing an overview on the sobel filter.
