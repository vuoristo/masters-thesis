\chapter{Video Filtering}
\section{Video Streams}
\fixme{Todo: YUV format}
\fixme{Is this needed?}

\section{Filter Application}
\label{sec:filterapp}
The objective of this thesis is to study the suitability of OpenEM framework
for stream processing. Today many different types of data can be streamed, for
example audio and video. Video was chosen to be the type of the streams used in
the experiments because there are many known image processing algorithms to use
as the basis for the study and there are many applications for video stream
processing in the context of industrial internet. \fixme{very crappy}

Three requirements for the workload applications were specified to guide the
design. The requirements are presented in the following list.

\begin{enumerate}
    \item{Variable input bitrates}
    \item{Comparability the PREESM and OpenEM applications}
    \item{Highly analyzable}
\end{enumerate}

\textbf{Variable input bitrates} were required of the workload applications to
make it possible to study the performance of the OpenEM framework in processing
dynamic workloads. Varying the bitrates of the video stream inputs is simple as
the frame size of the stream is easy to change and it doesn't affect the
algorithms used in any unforeseeable way. \textbf{Comparability of the PREESM
and OpenEM applications} was required so the PREESM workload could be used as a
baseline implementation. Last requirement for the applications was that they
needed to be \textbf{highly analyzable} in order to enable the study of OpenEM
performance. An application satisfying these requirements was designed using the
PREESM sobel example at \cite{preesmtut} as the starting point and adding
another processing component to it. It is important to notice that the actual
performance of the filter application in its nominal video filtering task was
mostly disregarded. For example the data is copied to a new buffer in every
processing stage and the filter algorithms are not optimized for the specific
platform. Therefore comparing the performance of the implemented applications to
real world implementations of similar applications is not useful.

The idea for using sobel and gauss filters in the same application came from
the canny edge detector, which is briefly discussed in \ref{subsec:canny}. The
canny edge detector only provided ideas of what a realistic video processing
application does. The filters in the workload applications are executing
independently of each other on separate video streams unlike how they are
connected in the canny edge detector. After the introduction to edge detection
and the canny edge detector the filter components implemented in this thesis are
introduced in \ref{subsec:gauss} introducing the gaussian filter and
\ref{subsec:sobel} providing an overview on the sobel filter.\\

\fixme{TODO: improve intro and find sources for claims. wikipedia on edge detection has
about the same stuff as above.}

\subsection{Canny edge detector}
\label{subsec:canny}
\fixme{this shouldn't probably be in construction chapter}
Edge detection is an important tool in image processing and computer vision.
Many image processing and computer vision algorithms operate on detected edges.
There is a growing interest in the industry to use DSP platforms for edge
detection based algorithms.

In his 1986 paper John F. Canny \cite{canny1986computational} lays out the
mathematical criteria for successful edge detection and presents an algorithm,
which is suitable for implementation on DSP platforms and achieves decent edge
detection performance. The Canny Edge Detection consists of five steps
presented in the following list.

\begin{enumerate}
    \item{Noise reduction}
    \item{Finding the intensity gradient of the image}
    \item{Non-maximum supression}
    \item{Double tresholding}
    \item{Edge tracking by hysteresis}
\end{enumerate}

The noise reduction in step one can be implemented with gaussian filtering.
Finding the intensity gradient of the image in step two can be implemented using
a sobel filter. Gauss and sobel filters are implemented in the thesis
experiment. Gaussian filtering is discussed in \ref{subsec:gauss} and sobel
filtering in \ref{subsec:sobel}. The rest of the steps are not implemented in
this thesis and thus are only briefly discussed here \fixme{is this ok to just
disregard stuff that's not going to be implemented?}.

In the canny edge detector the image is first filtered with gaussian filter to
reduce the amount of noise in the image. Second the changes in the intensity in
the image are detected using an edge detection operator such as the sobel
operator. The third step improves the accuracy of the edge detection by
supressing all but the strongest responses to the detected edges, in practice
``thinning'' the edges. The fourth step classifies the edge pixels to three
classes separated by empirically determined threshold values. The pixels with
gradient value above the high threshold are marked strong pixels and the pixels
with gradient value below the low threshold are supressed. In the fifth step the
remaining weak pixels with gradient values below the high threshold are
preserved or supressed according to the presence of strong pixels in their
neighborhood. Detailed description of the algorithm is presented in the original
paper by Canny \cite{canny1986computational}, information about implementing a
canny edge detector is available in \cite{gonzalez2008digital} and comparison of
its performace to other edge detectors can be found in \cite{maini2009study}.

\subsection{Gaussian filter}
\label{subsec:gauss}
Gaussian filtering is used for multiple purposes in digital image processing.
In the canny edge detector the gaussian filter is used to reduce noise in the
processed images. The gaussian filter works by convolving a gaussian function
with the input signal. Gaussian function is non-zero everywhere which means it
would theoretically require an infinite convolution window. Since the function
decays rapidly it is often reasonable to truncate the function and use small
windows. \cite{gonzalez2008digital} In the thesis experiment a kernel size of
5x5 is used.

In practice every pixel in the filtered image has an intensity value computed
by taking a weighted average of the neighboring pixels in the input image. The
weights are precalculated from the gaussian function, giving the highest weight
to the pixel in the center of the window. The gaussian filter displayed in
figure \ref{fig:gaussmat} was calculated with $\sigma$ = 1.3. The filtered
image has a smoothed appearance compared to the original image. \fixme{maybe add
a filtered image?}

\begin{figure}
    \begin{displaymath}
        B = \frac{1}{159}\begin{bmatrix}
             2 & 4 & 5 & 4 & 2 \\
             4 & 9 & 12 & 9 & 4 \\
             5 & 12 & 15 & 12 & 5 \\
             4 & 9 & 12 & 9 & 4 \\
             2 & 4 & 5 & 4 & 2 \\
        \end{bmatrix} \ast A
    \end{displaymath}
    \caption{The gaussian filter used in the filter applications. The
    convolution operation is denoted by the asterisk.}
    \label{fig:gaussmat}
\end{figure}

\subsection{Sobel filter}
\label{subsec:sobel}
The actual edge detection in the canny edge detector begins with applying the
sobel operator to the input image. The sobel operator is a discrete
differentiation operator. It consists of two 3x3 kernels which are convolved
with the image to approximate the derivatives. The two kernels represent
horizontal and vertical changes. At each point in the image the resulting
gradient approximations are combined giving an approximate gradient magnitude.
\cite{gonzalez2008digital} The convolution operations are presented in figure
\ref{fig:sobelmat}.

\begin{figure}
    \begin{displaymath}
        G_{x} = \begin{bmatrix}
            -1 & 0 & +1 \\
            -2 & 0 & +2 \\
            -1 & 0 & +1 \\
        \end{bmatrix} \ast A
    \end{displaymath}

    \begin{displaymath}
        G_{y} = \begin{bmatrix}
            -1 & -2 & -1 \\
            0 & 0 & 0 \\
            +1 & +2 & +1 \\
        \end{bmatrix} \ast A
    \end{displaymath}
    \caption{The Sobel Kernels used in the application to compute the gradient
    approximation. The asterisk denotes the convolution operation. \fixme{figure
    or formula or what?}}
    \label{fig:sobelmat}
\end{figure}
