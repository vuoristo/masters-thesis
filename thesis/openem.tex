\chapter{Open Event Machine}
\label{chapter:openem}
This thesis investigates the suitability of Open Event Machine (OpenEM) for
real-time stream processing. OpenEM is a programming framework for event-driven
multicore applications.

\section{OpenEM Framework}
\subsection{Overview}
OpenEM is an event-driven programming framework originally developed for the
networking data plane by Nokia Solutions and Networks. The OpenEM framework
provides a programming model for scalable and dynamically load balanced
applications. The key components of the OpenEM programming model are events,
execution objects, queues and the scheduler. OpenEM works with
run-to-completion principle which means once an event begins to execute it will
not be interrupted but will run until completed. The run-to-completion
principle implies limitations within which well performing applications must be
designed, the main limitations being the required small granule size for
computations and the lock-free implementation of the application.
\cite{openempage}

At the time of writing there are no public documentation resources for the NSN
OpenEM other than the documentation included in the OpenEM source files
available at \cite{openempage} and the introductory slides at
\cite{openemintro}. Hardware vendor implementations of OpenEM exist and may
have more complete documentation available as is the case for the Texas
Instruments OpenEM implementation introduced in section \ref{sec:tiopenem}.

The unit of communication in OpenEM is the Event described in
\ref{subsec:event}. Events are sent to Queues (\ref{subsec:queues}). Queues are
connected to Execution Objects (\ref{subsec:eos}). The scheduler
(\ref{subsec:schedule}) chooses an event from a suitable queue based on
scheduling rules and schedules it on a core.

\subsection{Events}
\label{subsec:event}
In the core of the OpenEM framework design is the event. The work to be done by
an OpenEM application is divided into application specific pieces of data
called events. OpenEM does not specify the event content to allow for the use
of hardware specific descriptors in OpenEM implementations for different
hardware platforms. Usually events carry pointers to messages or descriptors.
\cite{openemintro} For example in a network packet processing application an
arriving packet could be converted to or encapsulated by an event.

Event memory is managed by OpenEM, meaning the application allocates events
from OpenEM and freeing events returns the control of the memory to OpenEM
\cite{openemintro}.
\subsection{Execution Objects}
\label{subsec:eos}
The work to be done is described by the events but they don't describe how it
is done. For that purpose there are Execution Objects (EO), which contain the
application logic. The application is built from EOs connected by queues.
Multiple queues can be connected to an EO and an EO may execute on multiple
cores if the queue types of the connected queues allow for it.
\cite{openemintro}

The application logic for each EO is contained in three functions, namely
start, receive and stop, which will get called in different phases of the EO
lifecycle. EO construction and destruction are handled through the application
defined start and stop functions. The receive function will be called whenever
the EO has received an event and is scheduled on a core. \cite{openemintro}

OpenEM implementations will pass a pointer to an user defined context when
calling the receive function. The application designer has complete freedom
over the EO context contents as the OpenEM runtime only passes an user defined
pointer. \cite{openemintro} The application designer should note that as
locking is discouraged and the EO may execute on multiple cores simultaneously,
care must be exercised when accessing the EO context.
\subsection{Queues}
\label{subsec:queues}
\subsection{Scheduling}
\label{subsec:schedule}
\subsection{An Illustrative Example}
\label{subsec:example}
Present a graphical representation of a simple OpenEM application\\
Explain the execution of the application

\section{Texas Instruments Implementation of OpenEM}
\label{sec:tiopenem}
\subsection{Multicore Navigator and OpenEM}
Centralized Scheduler on a PDSP core\\
Hardware queues\\
\subsection{Other TI Specific OpenEM features}
Tracing\\
Event Preloading??\\
Initialization of OpenEM\\
Cache Coherency
\subsection{State of TI OpenEM Implementation}
Event Groups\\
Distributed Scheduling\\
Queue Group limitations\\
Execution Object context\\
Parallel Ordered Queue\\


